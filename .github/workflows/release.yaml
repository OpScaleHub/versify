name: Go Build and Release

on:
  push:
    branches: [ "main" ]
    # Trigger a release job when tags matching vX.X.X are pushed
    tags: [ 'v*.*.*' ]
  pull_request:
    branches: [ "main" ]

env:
  # IMPORTANT: Set your application's executable name here
  GO_APP_NAME: my-go-app

jobs:
  # --- BUILD AND TEST JOB: Handles cross-compilation and artifact generation ---
  build_and_test:
    runs-on: ubuntu-latest

    # Define a matrix for cross-compilation targets
    strategy:
      fail-fast: false
      matrix:
        include:
          # Linux builds (AMD64 and ARM64)
          - goos: linux
            goarch: amd64
          - goos: linux
            goarch: arm64
          # macOS build (AMD64 is common)
          - goos: darwin
            goarch: amd64
          # Windows build
          - goos: windows
            goarch: amd64

    steps:
    - uses: actions/checkout@v4

    - name: Set up Go ${{ matrix.goos }} / ${{ matrix.goarch }}
      uses: actions/setup-go@v4
      with:
        go-version: '1.21' # Updated to a stable, recent Go version

    # Run tests before building anything
    - name: Test
      run: go test -v ./...

    # Cross-compile for the current matrix combination
    - name: Build and Package Binary
      run: |
        # 1. Determine the file extension (exe for Windows, none otherwise)
        if [ "${{ matrix.goos }}" = "windows" ]; then
          EXT=".exe"
        else
          EXT=""
        fi

        # 2. Set output filename structure: app-name-os-arch(.ext)
        # Note: We assume the main package is in the root or a standard 'main' module path.
        # If your main package is under a subfolder, adjust the build path here (e.g., ./cmd/main)
        FILENAME="${{ env.GO_APP_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}${EXT}"

        echo "Building $FILENAME for GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }}"

        # Cross-compile and build the executable
        GOOS=${{ matrix.goos }} GOARCH=${{ matrix.goarch }} go build -o $FILENAME .

        # 3. Create a compressed archive (zip for Windows, tar.gz otherwise)
        if [ "${{ matrix.goos }}" = "windows" ]; then
          zip "${{ env.GO_APP_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}.zip" "$FILENAME"
          ARTIFACT_PATH="${{ env.GO_APP_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}.zip"
        else
          tar -czf "${{ env.GO_APP_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz" "$FILENAME"
          ARTIFACT_PATH="${{ env.GO_APP_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}.tar.gz"
        fi

        # Set the artifact path for upload using an environment variable
        echo "ARTIFACT_PATH=$ARTIFACT_PATH" >> $GITHUB_ENV


    # 4. Upload the packaged binary as an artifact
    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        # Use a unique name for each artifact
        name: ${{ env.GO_APP_NAME }}-${{ matrix.goos }}-${{ matrix.goarch }}
        path: ${{ env.ARTIFACT_PATH }}
        retention-days: 1 # Artifacts are temporary until released

  # --- RELEASE JOB: Creates the GitHub Release and uploads artifacts ---
  release:
    # This job only runs when a tag is pushed (e.g., refs/tags/v1.0.0)
    if: startsWith(github.ref, 'refs/tags/v')
    needs: [build_and_test]
    runs-on: ubuntu-latest

    steps:
    # 1. Download all artifacts produced by the build_and_test job
    - name: Download all build artifacts
      uses: actions/download-artifact@v4
      with:
        path: artifacts # Downloads all artifacts into a folder named 'artifacts'

    # 2. Create the GitHub Release and attach the binaries
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v2
      with:
        files: artifacts/**/* # Uploads all files found in the artifacts folder
        # Uses the tag name (e.g., v1.0.0) as the release title
        name: Release ${{ github.ref_name }}
        # Automatically generates release notes based on commits since the last tag
        generate_release_notes: true
